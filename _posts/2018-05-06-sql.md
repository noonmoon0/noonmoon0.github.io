---
layout: post
title:  "sql优化"
categories: sql优化
tags:  sql
author: zz
---

sql优化

- 表关联查询时务必遵循 小表驱动大表 原则；
- 使用查询语句 where 条件时，不允许出现 函数，否则索引会失效；
- LIKE 语句不允许使用 % 开头，否则索引会失效 
- 禁止使用select *

- 当只要一行数据时使用 limit                MySQL数据引擎会在找到一条结果停止搜索，会增加性能

- limit 的基数比较大时使用 between

1. - 用 not exists 代替 not in 

   not in 不能使用索引

   使用单表查询时，相同字段尽量不要用 OR，因为可能导致索引失效，比如：SELECT * FROM table WHERE name = '手机' OR name = '电脑'，可以使用 UNION 替代 

   4 尽量避免在列上做运算，这样导致索引失效

每张表都必须有 主键，达到加快查询效率的目的

- 索引不宜过多，根据实际情况决定，尽量不要超过 10 个； 
- 组合索引一定要遵循 从左到右 原则，否则索引会失效 



Mysql 中可以利用 alter table 语句来为表中的字段添加索引，语法为：alter table 表明

add index (字段名)；



- 分表，可根据业务字段尾数中的个位或十位或百位（以此类推）做表名达到分表的目的；
- 分库，可根据业务字段尾数中的个位或十位或百位（以此类推）做库名达到分库的目的；
- 表分区，类似于硬盘分区，可以将某个时间段的数据放在分区里，加快查询速度，可以配合 分表 + 表分区 结合使用
  

mysql 分库分表(数据给中间件,中间件分发 sharding jdbc(耦合较高,所有工程都需要引入依赖) mycat(需要单独运维部署))



垂直拆分  一个表拆开 每个表放几个字段 字段少 mysql缓存加载更多 速度更快

水平拆分  拆多库 一个表数据量庞大 同样的数据拆分到多个表中 例如库1 库2 库3 表1 表2 表3... sql查询例如orderID=11 对分的库或表数量进行取模% 结果分配

分法 按range分 有点:扩容方便 每个月都准备好一个库,到了新的月就自然写新库 缺点:大部分请求,都是新数据 实际生产用range,要看场景, 用户不仅仅是访问最新数据,而是均匀访问现有数据以及历史数据

按hash分 优点:可以平均分配每个库的数据量和请求压力,缺点 :扩容麻烦 例如按3个库分 orderID对3取模%就可以 

扩容会有一个数据迁移的过程



索引

索引是帮助mysql高效获取数据的排好序的数据结构

索引储存在文件里

索引结构 二叉树(红黑树,平衡树) hash btree(子节点大于父节点,右边大,对红黑树进行横向扩容)

innoDB引擎默认使用b+tree 必须要有主键 推荐使用整形自增主键

innoDB引擎一个表只生成2个文件(myisam生成3个,表结构,数据,索引)如果不建立会自动根据主键生成索引

b+tree 和b-tree (非叶子节点不存储data,b+多一个顺序指针,提高区间访问性能)

b+叶子节点存储磁盘文件指针(0x07)

b+tree 聚集索引 叶子节点包含完整的数据记录(索引+数据)

b+tree每个节点存储默认16K(4页(cpu最小读取单位))横向只存放索引 不存放数据 可以存放更多

b+tree 高度1-5 经过1-5次io就可以  3层就可以存放2000多万  每层1170个索引

b+tree叶子节点从左到右变大 推荐自增 就可以按顺序直接加节点插入 如果是uuid 如果插入可能插入之前的已满节点 就要做一个节点分裂,维护一下索引,之后再插入

二叉树节点存储 key(这一列的值)/value(数据对应的地址指针0x07)

如果不用索引 正常一个查询是逐行 需要进行大量磁盘I/O 性能较差

在mysql建立联合索引时会遵循最左前缀匹配的原则，即最左优先，在检索数据时从联合索引的最左边开始匹配 

使用联合索引的好处

- 减少开销。每多一个索引，都会增加写操作的开销和磁盘空间的开销。对于大量数据的表，使用联合索引会大大的减少开销！
- 效率高。索引列越多，通过索引筛选出的数据越少。



mysql5.6优化:索引下推  select * from b where id = 'xxx' and A like '%A%' and B like '%B%'

5.6之前会先查找id = 'xxx' 然后like匹配  索引下推会先返回id='xxx'的索引 然后根据like判断索引是否符合条件 不符合直接reject ,可以在有like条件查询的情况,减少回表次数
