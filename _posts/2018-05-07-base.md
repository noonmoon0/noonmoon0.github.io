---
layout: post
title:  "基础"
categories: 基础
tags:  基础
author: zz
---

slf4j 为java程序提供日志输出的统一接口    采用包装/外观模式，具体怎么实现的不关心 只是调用

slf4j 只是接口 没有实现    log4j是实现

 *1.ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构。 （LinkedList是双向链表，有next也有previous）     *

*2.对于随机访问get和set，ArrayList觉得优于LinkedList，因为LinkedList要移动指针。      

3.对于新增和删除操作add和remove，LinedList比较占优势，因为ArrayList要移动数据。*  



jvm 组成 类加载子系统 运行时数据区(内存结构) 执行引擎

jdk自带jvm调优工具 VisualVM命令jvisualvm



javap -c +字节码文件(.class) 反汇编生成更可读的

1. Java虚拟机栈（栈）(线程独享,存放方法(栈帧),先进后出)java方法执行的内存模型,存储java方法执行时的局部变量,含数据类型,对象引用,方法执行结束后释放 特点:线程私有,生命周期与线程相同
   栈帧:局部变量表,操作数栈(操作数据中转存储空间,操作完毕恢复空值),动态链接(运行时对象头指向类元信息的一个动态指针),方法出口
   每调用一个方法都会在栈内存中分配一块空间,循环调用导致栈内存溢出 栈帧默认内存是1M 可用命令设置 
   -Xss128K 设置为128K
2. 本地方法栈(调用C语言的,线程独享) 类似Java虚拟机栈，与Java虚拟机区别在于：服务对象，即 Java虚拟机栈为执行 Java 方法服务；本地方法栈为执行 Native方法服务  (一个Native Method就是一个java调用非java代码的接口 )
3. Java堆（堆,共享） 垃圾收集器管理的主要区域,也称GC堆, 存放java对象实例(new出来的对象,放在eden区)  特点:jvm中内存最大,线程共享   
   堆内存划分年轻代和老年代 年轻代划分eden区和survivor区 survivor区划分from和to区
   minorGC首先会一次清理eden,from,to 区 每清理一次年龄+1,默认经过15次(默认,可以配置)还未销毁,移动到老年代
4. 方法区(1.8之后元空间 ,共享 放物理内存中) 堆的一个逻辑部分 存储被虚拟机加载的 (类元信息,常量,静态变量)等数据 线程共享
5. 程序计数器(线程独享)  当前线程所执行的字节码 的 行号指示器  实现异常处理,线程恢复等功能  原理:通过改变计数器的值 来选取下一条执行的字节码命令  线程私有,内存小,为了让线程切换后恢复到正确的执行位置,每条线程都配有一个独立的程序计数器



1、强引用 Strong Reference 

 程序 创建一个对象，并且把这个对象赋值给一个引用变量，我们就称这个引用变量为强引用 

比如：

Object object =``new Object();

String str =``"hello"``;

 强引用有引用变量指向时永远不会被垃圾回收，JVM宁愿抛出OutOfMemory错误也不会回收这种对象。

2、软引用 Soft Reference 

如果一个对象具有软引用，内存空间足够，垃圾回收器就不会回收它； 如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。 

软引用可用来实现内存敏感的高速缓存,比如网页缓存、图片缓存等。使用软引用能防止内存泄露，增强程序的健壮性。    

3、弱引用 Weak Reference 

弱引用与软引用的性质类似。不同之处在于，对于弱引用指向的对象，无论内存是否够用，下次GC回收时，都会回收掉该块内存 

4、虚引用 Phantom Reference 

如果一个对象与虚引用关联，则跟没有引用与之关联一样，在任何时候都可能被垃圾回收器回收。 



GC

Major GC:清理永久代，但是由于很多MojorGC 是由MinorGC 触发的，所以有时候很难将MajorGC 和MinorGC区分开。 

MinorGC:

FullGC：是清理整个堆空间—包括年轻代和永久代。FullGC 一般消耗的时间比较长，远远大于MinorGC，因此，有时候我们必须降低FullGC 发生的频率。 



GC垃圾收集器  用的比较多的G1

GC算法

①引用计数法  已淘汰 难处理循环引用

②标记清除法 原理：将垃圾回收分为两个阶段：标记阶段和清除阶段。一种可行的实现是，在标记阶段，首先通过根节点，标记从根节点出发的可达对象，因此，未被标记的对象就是未被引用的垃圾对象，然后，在清除阶段，清除所有未被标记的对象。 

③标记压缩法 适用于存活对象较多的场合，如老年代。他在标记-清除的基础上做了一些优化，和标记-清除算法一样，标记-压缩算法也首先需要从根节点开始，对所有可达对象做一次标记，但是之后，它并不简单的清理未标记对象，而是将所有的存活对象压缩到内存的一端，之后，清除边界外所有的空间。 

④复制算法 --与标记-清除算法相比，复制算法是一种相对高效的回收方法

--不适用于存活对象比较多的场合，如老年代

原理：将原有的内存空间分为两块，每次只使用其中一块，在垃圾回收时，将正在使用的内存中的存活对象复制到未使用的内存块中，之后，清除正在使用的内存块中的所有对象，交换两个内存的角色，完成垃圾回收 

--复制算法最大问题：空间浪费 

⑤分代收集算法 原理：根据对象存活周期的不同将内存划分为几块，一般是把java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾收集时都发现大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率较高、没有额外空间对他进行分配担保，就必须使用“标记清除”或者“标记压缩”算法进行回收。



jvm调优 (调整full GC 次数过多)



java线程模型 与cpu缓存模型类似

线程访问主内存中的共享变量,会将内存中的共享变量 同步到一个自己的工作内存中

并发编程(可见性 原子性 有序性) 缓存不一致问题: 线程A B 同时运行 共享变量C ,AB线程都对C进行同步副本 B对常量修改 A不可见

volatile(不保证原子性,保证需要借助synchronized锁机制) : 多线程 可见性

volatile可见性底层(C)实现原理 :基于MESI缓存一致性协议  (内存屏障)通过汇编lock前缀指令,锁定这块内存区域并回写到主内存,此操作成为缓存锁定,写会主内存会导致其他线程工作内存失效

java内存模型底层原子操作(8种)1,read(读取)从主内存读取数据2,load(载入)将主内存数据写入工作内存 3,use(使用)从工作内存中读取数据计算4,assign(赋值)将计算好的值赋值到工作内存5,store(存储)将工作内存数据写入主内存6,write(写入)将store过去的变量赋值给主内存的变量7,lock(锁定)给主内存变量加锁,标识为线程独占状态8,unlock(解锁)给主内存变量解锁,解锁后其他线程可以锁定该变量

总线加锁(性能太低)使用lock和unlock将并发的多线程并行变为串行

MESI缓存一致性协议 多cpu同时从主内存中读取数据到高速缓存(工作内存),其中某个CPU修改缓存的数据,该数据会马上同步回主内存,其他cpu可以总线嗅探机制(类似监听)感知到数据变化从而将自己缓存的数据失效

write(回写)的时候加lock	其他线程读取的时候没有加锁再读 有轻微停顿
