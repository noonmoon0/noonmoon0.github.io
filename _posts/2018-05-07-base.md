---
layout: post
title:  "基础"
categories: 基础
tags:  基础
author: zz
---

slf4j 为java程序提供日志输出的统一接口    采用包装/外观模式，具体怎么实现的不关心 只是调用

slf4j 只是接口 没有实现    log4j是实现

 *1.ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构。 （LinkedList是双向链表，有next也有previous）     *

*2.对于随机访问get和set，ArrayList觉得优于LinkedList，因为LinkedList要移动指针。      

3.对于新增和删除操作add和remove，LinedList比较占优势，因为ArrayList要移动数据。*  

for循环删除list  使用迭代器  for循环会导致错位



jvm 组成 类加载子系统 运行时数据区(内存结构) 执行引擎

jdk自带jvm调优工具 VisualVM命令jvisualvm

java **jvm运行原理**

class字节码文件		通过**类加载子系统** 加载进jvm内存  然后通过**执行引擎**执行



**javap -c +字节码文件(.class) 反汇编生成更可读的**

1. `Java`虚拟机栈（栈）(**线程独享**,**存放方法(栈帧)**,**先进后出**)java方法执行的内存模型,存储java方法执行时的局部变量,含数据类型,对象引用,方法执行结束后释放 特点:线程私有,生命周期与线程相同

   **栈帧**:**局部变量表**,**操作数栈**(操作数据中转存储空间,操作完毕恢复空值),**动态链接**(运行时**对象头**指向类元信息的一个动态指针),**方法出口**

   **每调用一个方法都会在栈内存中分配一块空间**,循环调用导致栈内存溢出 栈帧默认内存是1M 可用命令设置 

   -Xss128K 设置为128K

2. 本地方法栈(**调用C语言的,线程独享**) 类似`Java`虚拟机栈，与Java虚拟机区别在于：服务对象，即 Java虚拟机栈为执行 `Java` 方法服务；本地方法栈为执行 `Native`方法服务  (一个Native Method就是一个java调用非java代码的接口 )

3. `Java`堆（堆,共享） 垃圾收集器管理的主要区域,也称GC堆, 存放java对象实例(new出来的对象,放在eden区)  特点:jvm中内存最大,线程共享   

   **堆内存划分**年轻代和老年代 年轻代划分eden区和survivor区 survivor区划分from和to区

   minorGC首先会一次清理eden,from,to 区 每清理一次年龄+1,默认经过15次(默认,可以配置)还未销毁,移动到老年代

4. 方法区(1.8之后**元空间** ,共享 放物理内存中) 堆的一个逻辑部分 存储被虚拟机加载的 (**类元信息,常量,静态变量**)等数据 线程共享

5. 程序计数器(线程独享)  当前线程所执行的**字节码** 的 **行号指示器**  实现异常处理,线程恢复等功能  原理:通过改变计数器的值 来选取下一条执行的字节码命令  线程私有,内存小,为了让线程切换后恢复到正确的执行位置,每条线程都配有一个独立的程序计数器



**1、强引用 Strong Reference** 

 程序 创建一个对象，并且把这个对象赋值给一个引用变量，我们就称这个引用变量为强引用 

比如：

`Object object =``new` `Object();`

`String str =``"hello"``;`

 强引用有引用变量指向时永远不会被垃圾回收，JVM宁愿抛出OutOfMemory错误也不会回收这种对象。

**2、软引用 Soft Reference** 

如果一个对象具有软引用，**内存空间足够**，垃圾回收器就不会回收它； 如果**内存空间不足**了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。 

软引用可用来实现内存敏感的高速缓存,比如网页缓存、图片缓存等。使用软引用能防止内存泄露，增强程序的健壮性。    

**3、弱引用 Weak Reference** 

弱引用与软引用的性质类似。不同之处在于，对于弱引用指向的对象，**无论内存是否够用**，下次GC回收时，都会回收掉该块内存 

**4、虚引用 Phantom Reference** 

如果一个对象与虚引用关联，则跟没有引用与之关联一样，在任何时候都可能被垃圾回收器回收。 



GC

Major GC:清理永久代，但是由于很多MojorGC 是由MinorGC 触发的，所以有时候很难将MajorGC 和MinorGC区分开。 

MinorGC:清理年轻代 

FullGC：是清理整个堆空间—包括年轻代和老年代。FullGC 一般消耗的时间比较长，远远大于MinorGC，因此，有时候我们必须降低FullGC 发生的频率。 



GC垃圾收集器  用的比较多的G1

GC算法

**①引用计数法**  已淘汰 难处理循环引用

**②标记清除法** 原理：将垃圾回收分为两个阶段：**标记**阶段和**清除**阶段。一种可行的实现是，在**标记**阶段，首先通过**根节点**，标记从根节点出发的可达对象，因此，未被标记的对象就是未被引用的垃圾对象，然后，在**清除**阶段，清除所有未被标记的对象。 

**③标记压缩法** 适用于存活对象较多的场合，如老年代。他在标记-清除的基础上做了一些优化，和标记-清除算法一样，标记-压缩算法也首先需要从根节点开始，对所有可达对象做一次标记，但是之后，它并不简单的清理未标记对象，而是将所有的**存活对象压缩到内存的一端**，之后，清除边界外所有的空间。 

**④复制算法** --与标记-清除算法相比，复制算法是一种相对高效的回收方法

--不适用于存活对象比较多的场合，如老年代

原理：将原有的内存空间分为两块，每次只使用其中一块，在垃圾回收时，将正在使用的内存中的存活对象复制到未使用的内存块中，之后，清除正在使用的内存块中的所有对象，交换两个内存的角色，完成垃圾回收 

**--复制算法最大问题：空间浪费** 

**⑤分代收集算法** 原理：根据对象**存活周期**的**不同**将内存划分为**几块**，一般是把java堆分为**新生代**和**老年代**，这样就可以**根据各个年代的特点采用最适当的收集算法**。在**新生代**中，每次垃圾收集时都发现大批对象死去，只有少量存活，那就选用**复制算法**，只需要付出少量存活对象的复制成本就可以完成收集。而**老年代**中因为对象存活率较高、没有额外空间对他进行分配担保，就必须使用“**标记清除**”或者“**标记压缩**”算法进行回收。



jvm调优 (调整full GC 次数过多)



java线程模型 与cpu缓存模型类似

线程访问主内存中的共享变量,会将内存中的共享变量 同步到一个自己的工作内存中

**并发编程**(可见性 原子性 有序性) 缓存不一致问题: 线程A B 同时运行 共享变量C ,AB线程都对C进行同步副本 B对常量修改 A不可见

volatile(不保证原子性,保证需要借助synchronized锁机制) : 多线程 可见性

**volatile可见性底层(C)实现原理** :基于MESI缓存一致性协议  (**内存屏障**)通过汇编lock前缀指令,锁定这块内存区域并回写到主内存,此操作成为缓存锁定,写会主内存会导致其他线程工作内存失效

java内存模型底层原子操作(8种)1**,read**(读取)从主内存读取数据2,**load**(载入)将主内存数据写入工作内存 3,**use**(使用)从工作内存中读取数据计算4,**assign**(赋值)将计算好的值赋值到工作内存5,**store**(存储)将工作内存数据写入主内存6,**write**(写入)将store过去的变量赋值给主内存的变量7,**lock**(锁定)给主内存变量加锁,标识为线程独占状态8,**unlock**(解锁)给主内存变量解锁,解锁后其他线程可以锁定该变量

**总线加锁**(性能太低)使用lock和unlock将并发的多线程并行变为串行

**MESI缓存一致性协议** 多cpu同时从主内存中读取数据到高速缓存(工作内存),其中某个CPU修改缓存的数据,该数据会马上同步回主内存,其他cpu可以**总线嗅探机制**(类似监听)感知到数据变化从而将自己缓存的数据失效

**write**(回写)的时候加lock	其他线程读取的时候没有加锁再读 有轻微停顿



# 线程池的几种方式与使用场景

在 `Executors` 类里面提供了一些静态工厂，生成一些常用的线程池。

1. `newFixedThreadPool`：创建固定大小的线程池。线程池的大小一旦达到最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。
2. `newCachedThreadPool`：创建一个可缓存的线程池。如果线程池的大小超过了处理任务所需要的线程，那么就会回收部分空闲（60秒不执行任务）的线程，当任务数增加时，此线程池又可以智能的添加新线程来处理任务。此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说 JVM）能够创建的最大线程大小。
3. `newSingleThreadExecutor`：创建一个单线程的线程池。这个线程池只有一个线程在工作，也就是相当于单线程串行执行所有任务。如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它。此线程池保证所有任务的执行顺序按照任务的提交顺序执行。
4. `newScheduledThreadPool`：创建一个大小无限的线程池。此线程池支持定时以及周期性执行任务的需求。
5. `newSingleThreadScheduledExecutor`：创建一个单线程的线程池。此线程池支持定时以及周期性执行任务的需求。



**一、ThreadPoolExecutor的重要参数**

 

- corePoolSize：核心线程数
- - 核心线程会一直存活，及时没有任务需要执行
  - 当线程数小于核心线程数时，即使有线程空闲，线程池也会优先创建新线程处理
  - 设置allowCoreThreadTimeout=true（默认false）时，核心线程会超时关闭
- queueCapacity：任务队列容量（阻塞队列）
- - 当核心线程数达到最大时，新任务会放在队列中排队等待执行
- maxPoolSize：最大线程数
- - 当线程数>=corePoolSize，且任务队列已满时。线程池会创建新线程来处理任务
  - 当线程数=maxPoolSize，且任务队列已满时，线程池会拒绝处理任务而抛出异常
- keepAliveTime：线程空闲时间
- - 当线程空闲时间达到keepAliveTime时，线程会退出，直到线程数量=corePoolSize
  - 如果allowCoreThreadTimeout=true，则会直到线程数量=0
- allowCoreThreadTimeout：允许核心线程超时
- rejectedExecutionHandler：任务拒绝处理器
- - 两种情况会拒绝处理任务：
  - - 当线程数已经达到maxPoolSize，切队列已满，会拒绝新任务
    - 当线程池被调用shutdown()后，会等待线程池里的任务执行完毕，再shutdown。如果在调用shutdown()和线程池真正shutdown之间提交任务，会拒绝新任务
  - 线程池会调用rejectedExecutionHandler来处理这个任务。如果没有设置默认是AbortPolicy，会抛出异常
  - ThreadPoolExecutor类有几个内部实现类来处理这类情况：
  - - AbortPolicy 丢弃任务，抛运行时异常
    - CallerRunsPolicy 执行任务
    - DiscardPolicy 忽视，什么都不会发生
    - DiscardOldestPolicy 从队列中踢出最先进入队列（最后一个执行）的任务
  - 实现RejectedExecutionHandler接口，可自定义处理器



**二、ThreadPoolExecutor执行顺序：** 

1. 当线程数小于核心线程数时，创建线程。

2. 当线程数大于等于核心线程数，且任务队列未满时，将任务放入任务队列。

3. 当线程数大于等于核心线程数，且任务队列已满

   若线程数小于最大线程数，创建线程

   若线程数等于最大线程数，抛出异常，拒绝任务



#### java锁

**synchronized** 原始采用的是 CPU 悲观锁机制，即线程获得的是独占锁。独占锁意味着其 他线程只能依靠阻塞来等待线程释放锁。 

**lock** 用的是乐观锁方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。乐观锁实现的机制就是 CAS 操作（Compare and Swap）。

当多个线程尝试使用 CAS 同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。 

CAS 操作包含三个操作数 —— 内存位置（V）、预期原值（A）和新值(B)。如果内存位置的值与预期原值相匹配，那么处理器会自动将该位置值更新为新值。 

CAS的缺点： 1.CPU开销较大 2.不能保证代码块的原子性  保证的只是一个变量的原子性操作 



#### Spring Bean 的生命周期

- Spring Bean 的生命周期简单易懂。在一个 bean 实例被初始化时，需要执行一系列的初始化操作以达到可用的状态。同样的，当一个 bean 不在被调用时需要进行相关的析构操作，并从 bean 容器中移除。

- Spring bean factory 负责管理在 spring 容器中被创建的 bean 的生命周期。Bean 的生命周期由两组回调（call back）方法组成。

  - 初始化之后调用的回调方法。

  - 销毁之前调用的回调方法。

    

    Spring 框架提供了以下四种方式来管理 bean 的生命周期事件：

    - InitializingBean 和 DisposableBean 回调接口
    - 针对特殊行为的其他 Aware 接口
    - Bean 配置文件中的 Custom init() 方法和 destroy() 方法
    - @PostConstruct 和 @PreDestroy 注解方式

#### Spring的两种动态代理：Jdk和Cglib 的区别和实现

java动态代理是利用反射机制生成一个实现代理接口的匿名类，在调用具体方法前调用InvokeHandler来处理。

而cglib动态代理是利用asm开源包，对代理对象类的class文件加载进来，通过修改其字节码生成子类来处理。

1、如果目标对象实现了`接口`，默认情况下会采用`JDK的动态代理`实现AOP
2、如果目标对象实现了接口，可以强制使用CGLIB实现AOP

3、如果目标对象没有实现了接口，`必须采用CGLIB库`，spring会自动在JDK动态代理和CGLIB之间转换

JDK动态代理和CGLIB字节码生成的区别？ （1）JDK动态代理只能对`实现了接口的类`生成代理，而不能针对类 （2）CGLIB是针对`类`实现代理，主要是对指定的类生成一个子类，覆盖其中的方法 因为是继承，所以该类或方法最好不要声明成final 